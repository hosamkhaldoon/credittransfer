// This code was generated by Cursor
using System.Text;
using System.Text.Json;
using System.IdentityModel.Tokens.Jwt;
using System.Diagnostics;

namespace CreditTransfer.Services.WebHandler.Services
{
    /// <summary>
    /// Service for Keycloak JWT authentication and token management
    /// </summary>
    public class KeycloakAuthenticationService : IKeycloakAuthenticationService
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<KeycloakAuthenticationService> _logger;
        private readonly IConfiguration _configuration;
        private readonly ActivitySource _activitySource;
        
        private string? _cachedToken;
        private DateTime _tokenExpiry = DateTime.MinValue;
        private readonly object _tokenLock = new object();

        public KeycloakAuthenticationService(
            HttpClient httpClient,
            ILogger<KeycloakAuthenticationService> logger,
            IConfiguration configuration,
            ActivitySource activitySource)
        {
            _httpClient = httpClient;
            _logger = logger;
            _configuration = configuration;
            _activitySource = activitySource;
        }

        public async Task<string> GetAccessTokenAsync()
        {
            using var activity = _activitySource.StartActivity("KeycloakAuthenticationService.GetAccessToken");
            
            lock (_tokenLock)
            {
                if (IsTokenValid())
                {
                    _logger.LogDebug("Using cached JWT token");
                    activity?.SetTag("token.cached", true);
                    return _cachedToken!;
                }
            }

            _logger.LogDebug("Acquiring new JWT token from Keycloak");
            activity?.SetTag("token.cached", false);
            
            return await RefreshTokenAsync();
        }

        public bool IsTokenValid()
        {
            lock (_tokenLock)
            {
                if (string.IsNullOrEmpty(_cachedToken))
                    return false;

                // Add a 30-second buffer before token expiry
                return DateTime.UtcNow < _tokenExpiry.AddSeconds(-30);
            }
        }

        public async Task<string> RefreshTokenAsync()
        {
            using var activity = _activitySource.StartActivity("KeycloakAuthenticationService.RefreshToken");
            
            // Retry mechanism for token acquisition
            const int maxRetries = 3;
            const int baseDelayMs = 1000;
            
            for (int attempt = 1; attempt <= maxRetries; attempt++)
            {
                try
                {
                    var tokenEndpoint = _configuration["Keycloak:TokenEndpoint"];
                    var clientId = _configuration["Keycloak:ClientId"];
                    var clientSecret = _configuration["Keycloak:ClientSecret"];
                    var grantType = _configuration["Keycloak:GrantType"] ?? "client_credentials";
                    var scope = _configuration["Keycloak:Scope"] ?? "openid profile email";

                    // Validate basic configuration
                    if (string.IsNullOrEmpty(tokenEndpoint))
                        throw new InvalidOperationException("Keycloak:TokenEndpoint configuration is missing");
                    if (string.IsNullOrEmpty(clientId))
                        throw new InvalidOperationException("Keycloak:ClientId configuration is missing");
                    if (string.IsNullOrEmpty(grantType))
                        throw new InvalidOperationException("Keycloak:GrantType configuration is missing");

                    // Validate endpoint URL format
                    if (!Uri.TryCreate(tokenEndpoint, UriKind.Absolute, out _))
                        throw new InvalidOperationException($"Keycloak:TokenEndpoint is not a valid URL: {tokenEndpoint}");

                _logger.LogDebug("Requesting token from Keycloak - Endpoint: {Endpoint}, ClientId: {ClientId}",
                    tokenEndpoint, clientId);

                activity?.SetTag("keycloak.endpoint", tokenEndpoint);
                activity?.SetTag("keycloak.client_id", clientId);
                activity?.SetTag("keycloak.grant_type", grantType);

                // Prepare token request based on grant type
                var requestContent = new List<KeyValuePair<string, string>>
                {
                    new("grant_type", grantType),
                    new("client_id", clientId),
                    new("scope", scope)
                };

                // Add credentials based on grant type
                if (grantType == "password")
                {
                    var username = _configuration["Keycloak:Username"];
                    var password = _configuration["Keycloak:Password"];
                    
                    if (string.IsNullOrEmpty(username))
                        throw new InvalidOperationException("Keycloak:Username configuration is missing for password grant type");
                    if (string.IsNullOrEmpty(password))
                        throw new InvalidOperationException("Keycloak:Password configuration is missing for password grant type");
                    
                    requestContent.Add(new("username", username));
                    requestContent.Add(new("password", password));
                    
                    _logger.LogDebug("Using password grant type with username: {Username}", username);
                    activity?.SetTag("keycloak.username", username);
                }
                else if (grantType == "client_credentials")
                {
                    if (string.IsNullOrEmpty(clientSecret))
                        throw new InvalidOperationException("Keycloak:ClientSecret configuration is missing for client_credentials grant type");
                    
                    requestContent.Add(new("client_secret", clientSecret));
                    
                    _logger.LogDebug("Using client_credentials grant type");
                }
                else
                {
                    throw new InvalidOperationException($"Unsupported grant type: {grantType}. Supported types are 'password' and 'client_credentials'");
                }

                var formContent = new FormUrlEncodedContent(requestContent);

                    //Make token request
                    var response = await _httpClient.PostAsync(tokenEndpoint, formContent);
                    var responseContent = await response.Content.ReadAsStringAsync();

                    activity?.SetTag("http.status_code", (int)response.StatusCode);

                if (!response.IsSuccessStatusCode)
                {
                    activity?.SetTag("error", true);
                    activity?.SetTag("error.message", responseContent);

                    _logger.LogError("Failed to acquire token from Keycloak - Status: {Status}, Response: {Response}",
                        response.StatusCode, responseContent);
                    
                    throw new HttpRequestException($"Token request failed: {response.StatusCode}");
                }

                // Parse token response
                var tokenResponse = JsonSerializer.Deserialize<TokenResponse>(responseContent);
                if (tokenResponse?.access_token == null)
                {
                    activity?.SetTag("error", true);
                    activity?.SetTag("error.message", "Invalid token response");

                    _logger.LogError("Invalid token response from Keycloak: {Response}", responseContent);
                    throw new InvalidOperationException("Invalid token response");
                }

                // Parse and validate JWT token
                var handler = new JwtSecurityTokenHandler();
                
                // Validate token format
                if (!handler.CanReadToken(tokenResponse.access_token))
                {
                    activity?.SetTag("error", true);
                    activity?.SetTag("error.message", "Invalid JWT token format");
                    
                    _logger.LogError("Received invalid JWT token format from Keycloak");
                    throw new InvalidOperationException("Invalid JWT token format received from Keycloak");
                }
                
                var jsonToken = handler.ReadJwtToken(tokenResponse.access_token);
                var expiry = jsonToken.ValidTo;
                
                // Validate token expiry
                if (expiry <= DateTime.UtcNow)
                {
                    activity?.SetTag("error", true);
                    activity?.SetTag("error.message", "Token already expired");
                    
                    _logger.LogError("Received expired JWT token from Keycloak - Expiry: {Expiry}", expiry);
                    throw new InvalidOperationException($"Received expired JWT token from Keycloak. Expiry: {expiry}");
                }
                
                // Validate token has sufficient validity period (at least 30 seconds)
                var validityDuration = expiry - DateTime.UtcNow;
                if (validityDuration.TotalSeconds < 30)
                {
                    activity?.SetTag("warning", true);
                    activity?.SetTag("warning.message", "Short token validity");
                    
                    _logger.LogWarning("JWT token has short validity period: {Duration} seconds", validityDuration.TotalSeconds);
                }

                                lock (_tokenLock)
                {
                    _cachedToken = tokenResponse.access_token;
                    _tokenExpiry = expiry;
                }

                activity?.SetTag("token.expires", expiry);
                activity?.SetTag("token.success", true);
                activity?.SetTag("token.validity.seconds", validityDuration.TotalSeconds);
                activity?.SetTag("token.issuer", jsonToken.Issuer);
                activity?.SetTag("token.subject", jsonToken.Subject);

                _logger.LogInformation("Successfully acquired JWT token - Expires: {Expiry}, Validity: {Validity}s, Issuer: {Issuer}",
                    expiry, validityDuration.TotalSeconds, jsonToken.Issuer);

                    return tokenResponse.access_token;
                }
                catch (HttpRequestException ex) when (attempt < maxRetries)
                {
                    var delay = baseDelayMs * (int)Math.Pow(2, attempt - 1); // Exponential backoff
                    
                    activity?.SetTag("retry.attempt", attempt);
                    activity?.SetTag("retry.delay", delay);
                    
                    _logger.LogWarning("HTTP error acquiring JWT token (attempt {Attempt}/{MaxAttempts}): {Error}. Retrying in {Delay}ms",
                        attempt, maxRetries, ex.Message, delay);
                    
                    await Task.Delay(delay);
                    continue;
                }
                catch (TaskCanceledException ex) when (attempt < maxRetries)
                {
                    var delay = baseDelayMs * (int)Math.Pow(2, attempt - 1);
                    
                    activity?.SetTag("retry.attempt", attempt);
                    activity?.SetTag("retry.delay", delay);
                    
                    _logger.LogWarning("Timeout acquiring JWT token (attempt {Attempt}/{MaxAttempts}): {Error}. Retrying in {Delay}ms",
                        attempt, maxRetries, ex.Message, delay);
                    
                    await Task.Delay(delay);
                    continue;
                }
                catch (InvalidOperationException)
                {
                    // Configuration errors should not be retried
                    throw;
                }
                catch (Exception ex) when (attempt < maxRetries)
                {
                    var delay = baseDelayMs * (int)Math.Pow(2, attempt - 1);
                    
                    activity?.SetTag("retry.attempt", attempt);
                    activity?.SetTag("retry.delay", delay);
                    
                    _logger.LogWarning("Unexpected error acquiring JWT token (attempt {Attempt}/{MaxAttempts}): {Error}. Retrying in {Delay}ms",
                        attempt, maxRetries, ex.Message, delay);
                    
                    await Task.Delay(delay);
                    continue;
                }
                catch (Exception ex)
                {
                    // Final attempt failed
                    activity?.SetTag("error", true);
                    activity?.SetTag("error.type", ex.GetType().Name);
                    activity?.SetTag("error.message", ex.Message);
                    activity?.SetTag("final.attempt", attempt);

                    _logger.LogError(ex, "Failed to acquire JWT token from Keycloak after {Attempts} attempts", maxRetries);
                    throw;
                }
            }
            
            // This should never be reached, but just in case
            throw new InvalidOperationException("Failed to acquire JWT token after all retry attempts");
        }

        public void ClearCachedToken()
        {
            lock (_tokenLock)
            {
                _cachedToken = null;
                _tokenExpiry = DateTime.MinValue;
            }
            
            _logger.LogInformation("Cached JWT token cleared");
        }

        public DateTime? GetTokenExpiry()
        {
            lock (_tokenLock)
            {
                return string.IsNullOrEmpty(_cachedToken) ? null : _tokenExpiry;
            }
        }

        /// <summary>
        /// Token response model for Keycloak
        /// </summary>
        private class TokenResponse
        {
            public string? access_token { get; set; }
            public int expires_in { get; set; }
            public string? token_type { get; set; }
            public string? scope { get; set; }
        }
    }
} 